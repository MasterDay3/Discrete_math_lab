# Збiрка користувацьких замовлень
Цей репозиторій містить реалізацію компʼютерного проєтку з дискретної математики.
## Мета роботи
Визначити, чи можливо зібрати кастомне замовлення на основі залежностей між компонентами.

Уявімо, що завод A виробляє кавові апарати різних моделей.
Клієнт може замовити базову модель та додати до неї певні додаткові компоненти.
Однак існують залежності між деталями:
деякі компоненти вимагають наявності інших, щоб їх можна було встановити
деякі компоненти конфліктують одна з одною
деякі модифікації займають місце або впливають на архітектуру апарату

## Завдання
Перевірити, чи можна зібрати замовлення клієнта, зважаючи на всі залежності.\
Якщо збірка можлива — вивести повний список компонент, які потрібно додати.

### Вхідні дані
+ список доступних товарів
+ список можливих додаткових компонент для кожного товару
+ список залежностей кожної компоненти
+ обов’язкові компоненти
+ несумісні компоненти

### Вихідні дані
+ чи можливо зібрати замовлення,
+ якщо так — повний перелік потрібних компонент, включаючи приховані залежності
+ якщо ні - повідомлення про це

## Алгоритм роботи
Користувач формує замовлення (базові компоненти + додаткові).\
Програма перевіряє:\
чи всі залежності виконані;\
чи немає конфліктів між компонентами.

Якщо збірка можлива:\
формується список компонентів (включаючи приховані залежності)

Якщо збірка неможлива:\
виводиться повідомлення про помилку

## Використані технології
Python — основна мова реалізації.\
Streamlit — для створення інтерактивного інтерфейсу.\
Алгоритми дискретної математики — для перевірки залежностей та конфліктів.

## Функції
### Algoritm
`get_only_required(content)` — формує словник односторонніх залежностей між компонентами.
`check_dependencies(selected_components, required_dict)` — перевіряє вибрані компоненти на наявність невиконаних залежностей.
`_dfs_recursive_helper(graph, current_node, target_node, visited)` — рекурсивно обходить граф у глибину для перевірки існування шляху.
`if_possible_path_dfs(graph, start_node, target_node)` — повертає True, якщо між двома вершинами існує шлях (DFS).
`parse_graph_to_dict(filename)` — зчитує граф із файлу та повертає словник суміжності і множину антивершин.
`check_request(request, filepath)` — перевіряє, чи компонент не конфліктує з власною антиверсією.
`add_component(request, user_list, filename)` — додає компонент у список, якщо він сумісний з уже вибраними.
`check_full_compatibility(component_list, target_component, filename)` — перевіряє відсутність шляху від будь-якого елемента у списку до цільового компонента.
`read_data(filepath)` — зчитує дані з файлу і повертає структуровані секції.
`get_necessary(content)` — будує словник необхідних залежностей між компонентами.
`create_packets(content)` — створює словник пакетів: назва → список компонентів.
`create_comp_dot(filename)` — генерує файл `main_graph.txt` з ребрами залежностей і несумісностей.
`get_user_graph(filename, choice, all_comps)` — будує граф користувацького вибору, додаючи ребра для вибраних і невибраних компонентів.
`remake_nesessary(line)` — парсить рядок залежностей і повертає компонент та список обов’язкових елементів.
`packet_remake(line)` — парсить рядок пакета та повертає його ключ і список компонентів.
`remake(line)` — парсить рядок несумісності та повертає пару конфліктних компонентів.

### Data
`read_data(filepath)`: Зчитує дані з файлу, розділяє їх на секції (списки рядків) за мітками ===== .... Повертає список секцій для подальшої обробки.\
`create_comp_dict(content)`: Створює словник словників із сумісністю компонентів. Для кожної пари компонентів зберігає True (сумісні) або False (несумісні).\
`create_packets(content)`: Формує словник пакетів: ключ — назва пакета, значення — список компонентів, що входять у нього.\
`get_uncompatable(content)`: Створює словник несумісностей: для кожного компонента зберігає список тих, із якими він конфліктує.\
`get_necessary(content)`: Створює словник необхідних залежностей: для кожного компонента зберігає список інших, які необхідні.\
`check(filename)`: Перевіряє складні залежності: якщо компонент А залежить від В, а В несумісний із С, то А теж стає несумісним із С. Повертає оновлений словник сумісності.\
`create_comp_dot(filename)`: Генерує основний граф залежностей у форматі DOT-файлу. Записує ребра для необхідностей та несумісностей.\
`user_graph(filename, selected, comps)`: Допоміжна функція для побудови графа на основі вибраних користувачем компонентів. Додає ребра між послідовно вибраними елементами та їхніми "анти"-версіями.\
`remake_nesessary(line)`: Допоміжна функція для розбору рядка залежностей виду "Компонент1 то Компонент2". Повертає пару компонентів, де другий може бути списком (якщо перелічено кілька через кому).\
`packet_remake(line)`: Допоміжна функція для обробки рядків із пакетами. Приймає рядок у форматі словника, розділяє його на дві частини: назву пакета (key) та список компонентів (value). Повертає кортеж: (назва пакета, список компонентів).\
`remake(line)`: Допоміжна функція для обробки рядків. Приймає рядок з двома компонентами(Компонент1 і Компонент2), ділить його на частини за словом "і". Повертає список з двох компонентів.

### Interface
`introduction()`: Виводить заголовок інтерфейсу, поле для введення імені користувача та привітання. Пояснює мету — перевірити можливість зібрати замовлення на основі залежностей між компонентами.\
`show_header_name(all_text)`: Зчитує назву з текстового файлу (рядок із міткою '===== Назва =====') і виводить її як заголовок.\
`show_components_checkboxes(components, column_count)`: Виводить усі доступні компоненти як чекбокси, розміщені у вказаній кількості колонок. Дозволяє користувачу обрати компоненти для замовлення.\
`show_packets_checkboxes(packets, column_count)`: Виводить доступні пакети як кнопки, розміщені у колонках. Кожен пакет містить набір компонентів.\
`tick_boxes_from_packets(packets)`: Активує чекбокси для всіх компонентів, що входять до вибраного пакета. Після натискання кнопки пакета, відповідні компоненти автоматично позначаються.\
`order(data, num)`: Основна логіка обробки замовлення. Виводить форму з чекбоксами для компонентів, обробляє вибір користувача, перевіряє сумісність компонентів, і виводить результат — успішне замовлення або повідомлення про конфлікти.\
`main()`: Головна функція запуску інтерфейсу. Зчитує дані з файлу, створює словники компонентів і пакетів, викликає функції для виводу інтерфейсу, обробки вибору та формування замовлення.

## Як запустити
Потрібно встановити бібліотеку для запуску інтерфейсу.\
Відкрийте `Terminal/Command Prompt` і введіть:
`pip install streamlit`

Скачайте або скопіюйте репозиторій `Discrete_math_lab` на свій комп’ютер.\
Якщо він на GitHub:
`git clone https://github.com/MasterDay3/Discrete_math_lab`

Якщо у вас просто папка — скопіюйте її у будь-яке місце.\
`cd Discrete_math_lab`

Запустити інтерфейс:\
У папці є файл `interface.py`\
Запустіть його командою:\
`streamlit run interface.py`\
Після цього Streamlit автоматично відкриє браузер

## Як використовувати
Введіть своє ім’я у полі вводу(за бажанням).\
Виберіть потрібні компоненти (чекбокси).\
За бажанням натисніть кнопку пакета (вибере групу компонентів).\
Натисніть кнопку “Зібрати замовлення”.\
Отримайте результат:\
Зелене повідомлення — замовлення можливе.\
Червоне повідомлення — замовлення неможливе (конфлікт між компонентами або відсутність залежних компонент).

### Автори

Студенти Українського Католицького Університету,\
Факультету прикладних наук:\
Забульський Микола,\
Воськало Любомир,\
Країло Павло,\
Якимів Юлія,\
Антонюк Андрій.
