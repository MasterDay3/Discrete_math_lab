# Збiрка користувацьких замовлень
Цей репозиторій містить реалізацію компʼютерного проєтку з дискретної математики.
## Мета роботи
Визначити, чи можливо зібрати кастомне замовлення на основі залежностей між компонентами.

Уявімо, що завод A виробляє кавові апарати різних моделей.
Клієнт може замовити базову модель та додати до неї певні додаткові компоненти.
Однак існують залежності між деталями:
деякі компоненти вимагають наявності інших, щоб їх можна було встановити
деякі компоненти конфліктують одна з одною
деякі модифікації займають місце або впливають на архітектуру апарату

## Завдання
Перевірити, чи можна зібрати замовлення клієнта, зважаючи на всі залежності.\
Якщо збірка можлива — вивести повний список компонент, які потрібно додати.

### Вхідні дані
+ список доступних товарів
+ список можливих додаткових компонент для кожного товару
+ список залежностей кожної компоненти
+ обов’язкові компоненти
+ несумісні компоненти

### Вихідні дані
+ чи можливо зібрати замовлення,
+ якщо так — повний перелік потрібних компонент, включаючи приховані залежності
+ якщо ні - повідомлення про це

## Алгоритм роботи
Користувач формує замовлення (базові компоненти + додаткові).\
Програма перевіряє:\
чи всі залежності виконані;\
чи немає конфліктів між компонентами.

Якщо збірка можлива:\
формується список компонентів (включаючи приховані залежності)

Якщо збірка неможлива:\
виводиться повідомлення про помилку

## Використані технології
Python — основна мова реалізації.\
Streamlit — для створення інтерактивного інтерфейсу.\
Алгоритми дискретної математики — для перевірки залежностей та конфліктів.

## Функції
### Algoritm
`get_only_required(content)` — формує словник односторонніх залежностей між компонентами.\
`check_dependencies(selected_components, required_dict)` — перевіряє вибрані компоненти на наявність невиконаних залежностей.\
`_dfs_recursive_helper(graph, current_node, target_node, visited)` — рекурсивно обходить граф у глибину для перевірки існування шляху.\
`if_possible_path_dfs(graph, start_node, target_node)` — повертає True, якщо між двома вершинами існує шлях (DFS).\
`parse_graph_to_dict(filename)` — зчитує граф із файлу та повертає словник суміжності і множину антивершин.\
`check_request(request, filepath)` — перевіряє, чи компонент не конфліктує з власною антиверсією.\
`add_component(request, user_list, filename)` — додає компонент у список, якщо він сумісний з уже вибраними.\
`check_full_compatibility(component_list, target_component, filename)` — перевіряє відсутність шляху від будь-якого елемента у списку до цільового компонента.\
`read_data(filepath)` — зчитує дані з файлу і повертає структуровані секції.\
`get_necessary(content)` — будує словник необхідних залежностей між компонентами.\
`create_packets(content)` — створює словник пакетів: назва → список компонентів.\
`create_comp_dot(filename)` — генерує файл `main_graph.txt` з ребрами залежностей і несумісностей.\
`get_user_graph(filename, choice, all_comps)` — будує граф користувацького вибору, додаючи ребра для вибраних і невибраних компонентів.\
`remake_nesessary(line)` — парсить рядок залежностей і повертає компонент та список обов’язкових елементів.\
`packet_remake(line)` — парсить рядок пакета та повертає його ключ і список компонентів.\
`remake(line)` — парсить рядок несумісності та повертає пару конфліктних компонентів.\

### Data
`read_data(filepath)` — зчитує дані з файлу і повертає структуровані секції (списки рядків) для подальшої обробки.\
`create_comp_dict(content)` — створює словник сумісності компонентів; True — сумісні, False — несумісні.\
`create_packets(content)` — створює словник пакетів: назва пакету → список компонентів.\
`get_uncompatable(content)` — будує словник несумісностей між компонентами.\
`get_necessary(content)` — створює словник необхідних компонентів для кожного компонента.\
`check(filename)` — перевіряє несумісності та залежності між компонентами і повертає оновлений словник сумісності.\
`create_comp_dot(filename)` — генерує `.dot` файл з графом залежностей та несумісностей компонентів.\
`user_graph(filename, selected, comps)` — будує граф користувацького вибору, додаючи ребра між обраними компонентами.\
`remake_nesessary(line)` — допоміжна функція: парсить рядок необхідності і повертає компонент та список обов’язкових елементів.\
`packet_remake(line)` — допоміжна функція: парсить рядок пакета і повертає ключ та список компонентів.\
`remake(line)` — допоміжна функція: парсить рядок несумісності і повертає пару конфліктних компонентів.\

### Interface
`create_comp_dict(all_text)` — створює словник компонентів з файлу; ключ — назва компонента, значення — False (необраний).\
`introduction()` — виводить вступний блок інтерфейсу та просить користувача ввести своє ім’я.\
`show_header_name(all_text)` — виводить заголовок із назвою замовлення з секцій файлу.\
`tick_boxes_from_packets(packets)` — створює кнопки-пакети; при натисканні автоматично активує всі чекбокси компонентів пакету.\
`order(data, all_txt, num)` — основна функція збору замовлення: виводить чекбокси для компонентів, перевіряє сумісність (`check_full_compatibility`) та необхідні залежності (`get_only_required`, `check_dependencies`). Повертає список обраних компонентів, якщо замовлення можливе.\
`main()` — головна функція Streamlit; налаштовує сторінку, читає дані (`read_data`), створює граф (`create_comp_dot`), ініціалізує словник компонентів (`create_comp_dict`) та пакети (`create_packets`), запускає введення користувача (`introduction`, `show_header_name`) та форму для вибору компонентів (`order`).\
`remake_nesessary(line)` — допоміжна функція для парсингу рядка з необхідними компонентами; повертає компонент та список або один необхідний компонент.\
`packet_remake(line)` — допоміжна функція для парсингу рядка пакета; повертає назву пакета та список компонентів у ньому.\
`remake(line)` — допоміжна функція для парсингу рядка несумісності; повертає два компоненти, які конфліктують.\

## Як запустити
Потрібно встановити бібліотеку для запуску інтерфейсу.\
Відкрийте `Terminal/Command Prompt` і введіть:
`pip install streamlit`

Скачайте або скопіюйте репозиторій `Discrete_math_lab` на свій комп’ютер.\
Якщо він на GitHub:
`git clone https://github.com/MasterDay3/Discrete_math_lab`

Якщо у вас просто папка — скопіюйте її у будь-яке місце.\
`cd Discrete_math_lab`

Запустити інтерфейс:\
У папці є файл `interface.py`\
Запустіть його командою:\
`streamlit run interface.py`\
Після цього Streamlit автоматично відкриє браузер

## Як використовувати
Введіть своє ім’я у полі вводу(за бажанням).\
Виберіть потрібні компоненти (чекбокси).\
За бажанням натисніть кнопку пакета (вибере групу компонентів).\
Натисніть кнопку “Зібрати замовлення”.\
Отримайте результат:\
Зелене повідомлення — замовлення можливе.\
Червоне повідомлення — замовлення неможливе (конфлікт між компонентами або відсутність залежних компонент).

### Автори

Студенти Українського Католицького Університету,\
Факультету прикладних наук:\
Забульський Микола,\
Воськало Любомир,\
Країло Павло,\
Якимів Юлія,\
Антонюк Андрій.
